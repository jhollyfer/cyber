---
id: ssr
title: Server Rendering & Hydration
---

Neste guia você vai aprender como usar React Query com server rendering.

Veja o guia sobre [Prefetching & Integração com Router](./prefetching.md) para algum contexto. Você também pode querer conferir o [guia de Performance & Request Waterfalls](./request-waterfalls.md) antes disso.

Para padrões avançados de server rendering, como streaming, Server Components e o novo app router do Next.js, veja o [guia Avançado de Server Rendering](./advanced-ssr.md).

Se você só quer ver código, pode pular direto para o [Exemplo completo com Next.js pages router](#full-nextjs-pages-router-example) ou o [Exemplo completo com Remix](#full-remix-example) abaixo.

## Server Rendering & React Query

Então, o que é server rendering afinal? O restante deste guia vai assumir que você está familiarizado com o conceito, mas vamos dedicar um tempo para ver como ele se relaciona com React Query. Server rendering é o ato de gerar o HTML inicial no servidor, para que o usuário tenha algum conteúdo para visualizar assim que a página carregar. Isso pode acontecer sob demanda quando uma página é solicitada (SSR). Também pode acontecer antecipadamente, seja porque uma requisição anterior foi cacheada, ou no momento do build (SSG).

Se você leu o guia de Request Waterfalls, talvez se lembre disto:

```
1. |-> Markup (without content)
2.   |-> JS
3.     |-> Query
```

Com uma aplicação renderizada no cliente, essas são as 3 viagens de ida e volta mínimas ao servidor que você precisará fazer antes de obter qualquer conteúdo na tela para o usuário. Uma maneira de ver o server rendering é que ele transforma o cenário acima nisto:

```
1. |-> Markup (with content AND initial data)
2.   |-> JS
```

Assim que o passo **1.** estiver completo, o usuário pode ver o conteúdo e quando o passo **2.** terminar, a página fica interativa e clicável. Como o markup também contém os dados iniciais que precisamos, o passo **3.** não precisa ser executado no cliente, pelo menos até que você queira revalidar os dados por algum motivo.

Tudo isso é da perspectiva do cliente. No servidor, precisamos fazer **prefetch** desses dados antes de gerar/renderizar o markup, precisamos fazer **dehydrate** desses dados em um formato serializável que possamos incorporar no markup, e no cliente precisamos fazer **hydrate** desses dados em um cache do React Query para evitar fazer um novo fetch no cliente.

Continue lendo para aprender como implementar esses três passos com React Query.

## Uma nota rápida sobre Suspense

Este guia usa a API regular `useQuery`. Embora não recomendemos necessariamente, é possível substituir por `useSuspenseQuery` **desde que você sempre faça prefetch de todas as suas queries**. A vantagem é que você pode usar `<Suspense>` para estados de carregamento no cliente.

Se você esquecer de fazer prefetch de uma query quando estiver usando `useSuspenseQuery`, as consequências dependerão do framework que você está usando. Em alguns casos, os dados sofrerão Suspend e serão buscados no servidor, mas nunca serão hidratados para o cliente, onde serão buscados novamente. Nesses casos, você terá um erro de hydration do markup, porque o servidor e o cliente tentaram renderizar coisas diferentes.

## Configuração inicial

O primeiro passo para usar React Query é sempre criar um `queryClient` e envolver a aplicação em um `<QueryClientProvider>`. Ao fazer server rendering, é importante criar a instância do `queryClient` **dentro da sua aplicação**, no state do React (uma instance ref também funciona). **Isso garante que os dados não sejam compartilhados entre diferentes usuários e requisições**, enquanto ainda cria o `queryClient` apenas uma vez por ciclo de vida do component.

Next.js pages router:

```tsx
// _app.tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

// NEVER DO THIS:
// const queryClient = new QueryClient()
//
// Creating the queryClient at the file root level makes the cache shared
// between all requests and means _all_ data gets passed to _all_ users.
// Besides being bad for performance, this also leaks any sensitive data.

export default function MyApp({ Component, pageProps }) {
  // Instead do this, which ensures each request has its own cache:
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
    </QueryClientProvider>
  );
}
```

Remix:

```tsx
// app/root.tsx
import { Outlet } from "@remix-run/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

export default function MyApp() {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <Outlet />
    </QueryClientProvider>
  );
}
```

## Comece rápido com `initialData`

A maneira mais rápida de começar é não envolver o React Query quando se trata de prefetching e não usar as APIs `dehydrate`/`hydrate`. O que você faz em vez disso é passar os dados brutos como a opção `initialData` para `useQuery`. Vamos ver um exemplo usando o Next.js pages router, com `getServerSideProps`.

```tsx
export async function getServerSideProps() {
  const posts = await getPosts();
  return { props: { posts } };
}

function Posts(props) {
  const { data } = useQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
    initialData: props.posts,
  });

  // ...
}
```

Isso também funciona com `getStaticProps` ou até mesmo o mais antigo `getInitialProps`, e o mesmo padrão pode ser aplicado em qualquer outro framework que tenha funções equivalentes. Este é o mesmo exemplo com Remix:

```tsx
export async function loader() {
  const posts = await getPosts();
  return json({ posts });
}

function Posts() {
  const { posts } = useLoaderData<typeof loader>();

  const { data } = useQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
    initialData: posts,
  });

  // ...
}
```

A configuração é mínima e pode ser uma solução rápida para alguns casos, mas existem **algumas contrapartidas a considerar** quando comparada à abordagem completa:

- Se você está chamando `useQuery` em um component mais abaixo na árvore, precisa passar o `initialData` até esse ponto
- Se você está chamando `useQuery` com a mesma query em múltiplos lugares, passar `initialData` para apenas um deles pode ser frágil e quebrar quando sua aplicação muda. Se você remover ou mover o component que tem o `useQuery` com `initialData`, o `useQuery` mais profundamente aninhado pode não ter mais dados. Passar `initialData` para **todas** as queries que precisam também pode ser trabalhoso.
- Não há como saber em que momento a query foi buscada no servidor, então `dataUpdatedAt` e a determinação se a query precisa de refetching são baseados em quando a página foi carregada
- Se já existem dados no cache para uma query, `initialData` nunca sobrescreverá esses dados, **mesmo que os novos dados sejam mais recentes que os antigos**.
  - Para entender por que isso é especialmente ruim, considere o exemplo `getServerSideProps` acima. Se você navegar para frente e para trás em uma página várias vezes, `getServerSideProps` seria chamado a cada vez e buscaria novos dados, mas como estamos usando a opção `initialData`, o cache do cliente e os dados nunca seriam atualizados.

Configurar a solução completa de hydration é simples e não tem essas desvantagens; esse será o foco para o restante da documentação.

## Usando as APIs de Hydration

Com apenas um pouco mais de configuração, você pode usar um `queryClient` para fazer prefetch de queries durante uma fase de pré-carregamento, passar uma versão serializada desse `queryClient` para a parte de rendering da aplicação e reutilizá-lo lá. Isso evita as desvantagens mencionadas acima. Sinta-se à vontade para pular para os exemplos completos do Next.js pages router e Remix, mas em nível geral esses são os passos extras:

- Na função loader do framework, crie um `const queryClient = new QueryClient(options)`
- Na função loader, faça `await queryClient.prefetchQuery(...)` para cada query que deseja fazer prefetch
  - Você deve usar `await Promise.all(...)` para buscar as queries em paralelo quando possível
  - Não há problema em ter queries que não recebem prefetch. Essas não serão renderizadas no servidor; em vez disso, serão buscadas no cliente após a aplicação ficar interativa. Isso pode ser ótimo para conteúdo que é mostrado apenas após interação do usuário, ou que está bem abaixo na página para evitar bloquear conteúdo mais crítico.
- Do loader, retorne `dehydrate(queryClient)`. Note que a sintaxe exata para retornar isso difere entre frameworks
- Envolva sua árvore com `<HydrationBoundary state={dehydratedState}>` onde `dehydratedState` vem do loader do framework. Como você obtém `dehydratedState` também difere entre frameworks.
  - Isso pode ser feito para cada route, ou no topo da aplicação para evitar boilerplate; veja os exemplos

> Um detalhe interessante é que na verdade existem _três_ `queryClient`s envolvidos. Os loaders do framework são uma forma de fase de "pré-carregamento" que acontece antes do rendering, e essa fase tem seu próprio `queryClient` que faz o prefetching. O resultado desidratado dessa fase é passado para **ambos** o processo de server rendering **e** o processo de client rendering, que possuem cada um seu próprio `queryClient`. Isso garante que ambos comecem com os mesmos dados para que possam retornar o mesmo markup.

> Server Components são outra forma de fase de "pré-carregamento", que também pode "pré-carregar" (pré-renderizar) partes de uma árvore de components React. Leia mais no [guia Avançado de Server Rendering](./advanced-ssr.md).

### Exemplo completo com Next.js pages router

> Para documentação do app router, veja o [guia Avançado de Server Rendering](./advanced-ssr.md).

Configuração inicial:

```tsx
// _app.tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

export default function MyApp({ Component, pageProps }) {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
    </QueryClientProvider>
  );
}
```

Em cada route:

```tsx
// pages/posts.tsx
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
  useQuery,
} from "@tanstack/react-query";

// This could also be getServerSideProps
export async function getStaticProps() {
  const queryClient = new QueryClient();

  await queryClient.prefetchQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
  });

  return {
    props: {
      dehydratedState: dehydrate(queryClient),
    },
  };
}

function Posts() {
  // This useQuery could just as well happen in some deeper child to
  // the <PostsRoute>, data will be available immediately either way
  const { data } = useQuery({ queryKey: ["posts"], queryFn: getPosts });

  // This query was not prefetched on the server and will not start
  // fetching until on the client, both patterns are fine to mix
  const { data: commentsData } = useQuery({
    queryKey: ["posts-comments"],
    queryFn: getComments,
  });

  // ...
}

export default function PostsRoute({ dehydratedState }) {
  return (
    <HydrationBoundary state={dehydratedState}>
      <Posts />
    </HydrationBoundary>
  );
}
```

### Exemplo completo com Remix

Configuração inicial:

```tsx
// app/root.tsx
import { Outlet } from "@remix-run/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

export default function MyApp() {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <Outlet />
    </QueryClientProvider>
  );
}
```

Em cada route, note que também é possível fazer isso em routes aninhadas:

```tsx
// app/routes/posts.tsx
import { json } from "@remix-run/node";
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
  useQuery,
} from "@tanstack/react-query";

export async function loader() {
  const queryClient = new QueryClient();

  await queryClient.prefetchQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
  });

  return json({ dehydratedState: dehydrate(queryClient) });
}

function Posts() {
  // This useQuery could just as well happen in some deeper child to
  // the <PostsRoute>, data will be available immediately either way
  const { data } = useQuery({ queryKey: ["posts"], queryFn: getPosts });

  // This query was not prefetched on the server and will not start
  // fetching until on the client, both patterns are fine to mix
  const { data: commentsData } = useQuery({
    queryKey: ["posts-comments"],
    queryFn: getComments,
  });

  // ...
}

export default function PostsRoute() {
  const { dehydratedState } = useLoaderData<typeof loader>();
  return (
    <HydrationBoundary state={dehydratedState}>
      <Posts />
    </HydrationBoundary>
  );
}
```

## Opcional - Remover boilerplate

Ter essa parte em cada route pode parecer muito boilerplate:

```tsx
export default function PostsRoute({ dehydratedState }) {
  return (
    <HydrationBoundary state={dehydratedState}>
      <Posts />
    </HydrationBoundary>
  );
}
```

Embora não haja nada de errado com essa abordagem, se você quiser se livrar desse boilerplate, veja como você pode modificar sua configuração no Next.js:

```tsx
// _app.tsx
import {
  HydrationBoundary,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

export default function MyApp({ Component, pageProps }) {
  const [queryClient] = React.useState(() => new QueryClient())

  return (
    <QueryClientProvider client={queryClient}>
      <HydrationBoundary state={pageProps.dehydratedState}>
        <Component {...pageProps} />
      </HydrationBoundary>
    </QueryClientProvider>
  )
}

// pages/posts.tsx
// Remove PostsRoute with the HydrationBoundary and instead export Posts directly:
export default function Posts() { ... }
```

Com Remix, isso é um pouco mais trabalhoso. Recomendamos conferir o pacote [use-dehydrated-state](https://github.com/maplegrove-io/use-dehydrated-state).

## Fazendo prefetch de queries dependentes

No guia de Prefetching aprendemos como [fazer prefetch de queries dependentes](./prefetching.md#dependent-queries--code-splitting), mas como fazemos isso em loaders de framework? Considere o seguinte código, retirado do [guia de Queries Dependentes](./dependent-queries.md):

```tsx
// Get the user
const { data: user } = useQuery({
  queryKey: ["user", email],
  queryFn: getUserByEmail,
});

const userId = user?.id;

// Then get the user's projects
const {
  status,
  fetchStatus,
  data: projects,
} = useQuery({
  queryKey: ["projects", userId],
  queryFn: getProjectsByUser,
  // The query will not execute until the userId exists
  enabled: !!userId,
});
```

Como faríamos prefetch disso para que possa ser renderizado no servidor? Aqui está um exemplo:

```tsx
// For Remix, rename this to loader instead
export async function getServerSideProps() {
  const queryClient = new QueryClient();

  const user = await queryClient.fetchQuery({
    queryKey: ["user", email],
    queryFn: getUserByEmail,
  });

  if (user?.userId) {
    await queryClient.prefetchQuery({
      queryKey: ["projects", userId],
      queryFn: getProjectsByUser,
    });
  }

  // For Remix:
  // return json({ dehydratedState: dehydrate(queryClient) })
  return { props: { dehydratedState: dehydrate(queryClient) } };
}
```

Isso pode ficar mais complexo, é claro, mas como essas funções loader são apenas JavaScript, você pode usar todo o poder da linguagem para construir sua lógica. Certifique-se de fazer prefetch de todas as queries que deseja que sejam renderizadas no servidor.

## Tratamento de erros

React Query tem como padrão uma estratégia de degradação graciosa. Isso significa:

- `queryClient.prefetchQuery(...)` nunca lança erros
- `dehydrate(...)` inclui apenas queries bem-sucedidas, não as que falharam

Isso fará com que quaisquer queries que falharam sejam tentadas novamente no cliente e que a saída renderizada no servidor inclua estados de carregamento em vez do conteúdo completo.

Embora seja um bom padrão, às vezes não é o que você quer. Quando conteúdo crítico está faltando, você pode querer responder com um código de status 404 ou 500 dependendo da situação. Para esses casos, use `queryClient.fetchQuery(...)` em vez disso, que lançará erros quando falhar, permitindo que você trate as coisas de maneira adequada.

```tsx
let result

try {
  result = await queryClient.fetchQuery(...)
} catch (error) {
  // Handle the error, refer to your framework documentation
}

// You might also want to check and handle any invalid `result` here
```

Se por algum motivo você quiser incluir queries que falharam no state desidratado para evitar novas tentativas, pode usar a opção `shouldDehydrateQuery` para sobrescrever a função padrão e implementar sua própria lógica:

```tsx
dehydrate(queryClient, {
  shouldDehydrateQuery: (query) => {
    // This will include all queries, including failed ones,
    // but you can also implement your own logic by inspecting `query`
    return true;
  },
});
```

## Serialização

Ao fazer `return { props: { dehydratedState: dehydrate(queryClient) } }` no Next.js, ou `return json({ dehydratedState: dehydrate(queryClient) })` no Remix, o que acontece é que a representação `dehydratedState` do `queryClient` é serializada pelo framework para que possa ser incorporada no markup e transportada para o cliente.

Por padrão, esses frameworks suportam apenas retornar coisas que são seguramente serializáveis/parseáveis, e, portanto, não suportam `undefined`, `Error`, `Date`, `Map`, `Set`, `BigInt`, `Infinity`, `NaN`, `-0`, expressões regulares, etc. Isso também significa que você não pode retornar nenhuma dessas coisas das suas queries. Se retornar esses valores é algo que você deseja, confira o [superjson](https://github.com/blitz-js/superjson) ou pacotes similares.

Se você está usando uma configuração SSR customizada, precisa cuidar desse passo por conta própria. Seu primeiro instinto pode ser usar `JSON.stringify(dehydratedState)`, mas como isso não escapa coisas como `<script>alert('Oh no..')</script>` por padrão, isso pode facilmente levar a **vulnerabilidades XSS** na sua aplicação. O [superjson](https://github.com/blitz-js/superjson) também **não** escapa valores e é inseguro para uso por si só em uma configuração SSR customizada (a menos que você adicione um passo extra para escapar a saída). Em vez disso, recomendamos usar uma biblioteca como [Serialize JavaScript](https://github.com/yahoo/serialize-javascript) ou [devalue](https://github.com/Rich-Harris/devalue) que são seguras contra injeções XSS por padrão.

## Uma nota sobre request waterfalls

No [guia de Performance & Request Waterfalls](./request-waterfalls.md) mencionamos que revisitaríamos como o server rendering muda um dos waterfalls aninhados mais complexos. Volte para o [exemplo de código específico](./request-waterfalls#code-splitting), mas como recapitulação, temos um component `<GraphFeedItem>` com code splitting dentro de um component `<Feed>`. Ele só renderiza se o feed contém um item de gráfico e ambos esses components buscam seus próprios dados. Com client rendering, isso leva ao seguinte request waterfall:

```
1. |> Markup (without content)
2.   |> JS for <Feed>
3.     |> getFeed()
4.       |> JS for <GraphFeedItem>
5.         |> getGraphDataById()
```

O legal do server rendering é que podemos transformar o cenário acima nisto:

```
1. |> Markup (with content AND initial data)
2.   |> JS for <Feed>
2.   |> JS for <GraphFeedItem>
```

Note que as queries não são mais buscadas no cliente; em vez disso, seus dados foram incluídos no markup. A razão pela qual agora podemos carregar o JS em paralelo é que, como `<GraphFeedItem>` foi renderizado no servidor, sabemos que vamos precisar desse JS no cliente também e podemos inserir uma script-tag para esse chunk no markup. No servidor, ainda teríamos esse request waterfall:

```
1. |> getFeed()
2.   |> getGraphDataById()
```

Simplesmente não podemos saber antes de buscar o feed se também precisamos buscar os dados do gráfico; elas são queries dependentes. Como isso acontece no servidor, onde a latência é geralmente mais baixa e mais estável, muitas vezes não é um problema tão grande.

Incrível, achatamos nossos waterfalls na maior parte! Há um porém, no entanto. Vamos chamar essa página de `/feed`, e vamos supor que também temos outra página como `/posts`. Se digitarmos `www.example.com/feed` diretamente na barra de URL e apertarmos enter, obtemos todos esses ótimos benefícios de server rendering, MAS, se em vez disso digitarmos `www.example.com/posts` e depois **clicarmos em um link** para `/feed`, voltamos a isto:

```
1. |> JS for <Feed>
2.   |> getFeed()
3.     |> JS for <GraphFeedItem>
4.       |> getGraphDataById()
```

Isso acontece porque com SPA's, server rendering só funciona para o carregamento inicial da página, não para qualquer navegação subsequente.

Frameworks modernos frequentemente tentam resolver isso buscando o código e os dados iniciais em paralelo, então se você estivesse usando Next.js ou Remix com os padrões de prefetching que descrevemos neste guia, incluindo como fazer prefetch de queries dependentes, na verdade ficaria assim:

```
1. |> JS for <Feed>
1. |> getFeed() + getGraphDataById()
2.   |> JS for <GraphFeedItem>
```

Isso é muito melhor, mas se quisermos melhorar ainda mais, podemos achatar isso em uma única viagem de ida e volta com Server Components. Aprenda como no [guia Avançado de Server Rendering](./advanced-ssr.md).

## Dicas, Truques e Ressalvas

### Stale é medido a partir de quando a query foi buscada no servidor

Uma query é considerada stale dependendo do seu `dataUpdatedAt`. Uma ressalva aqui é que o servidor precisa ter o horário correto para que isso funcione adequadamente, mas o horário UTC é usado, então fusos horários não interferem nisso.

Como `staleTime` tem o padrão de `0`, queries serão rebuscadas em segundo plano no carregamento da página por padrão. Você pode querer usar um `staleTime` mais alto para evitar esse fetching duplo, especialmente se você não cacheia seu markup.

Esse refetching de queries stale é uma combinação perfeita ao cachear markup em uma CDN! Você pode definir o tempo de cache da página em si razoavelmente alto para evitar ter que re-renderizar páginas no servidor, mas configurar o `staleTime` das queries mais baixo para garantir que os dados sejam rebuscados em segundo plano assim que um usuário visitar a página. Talvez você queira cachear as páginas por uma semana, mas refetch os dados automaticamente no carregamento da página se tiverem mais de um dia?

### Alto consumo de memória no servidor

Caso você esteja criando o `QueryClient` para cada requisição, React Query cria o cache isolado para esse cliente, que é preservado na memória pelo período do `gcTime`. Isso pode levar a alto consumo de memória no servidor em caso de um grande número de requisições durante esse período.

No servidor, `gcTime` tem o padrão de `Infinity`, que desabilita garbage collection manual e limpa automaticamente a memória assim que uma requisição é finalizada. Se você está definindo explicitamente um `gcTime` diferente de Infinity, será responsável por limpar o cache antecipadamente.

Evite definir `gcTime` como `0` pois isso pode resultar em um erro de hydration. Isso ocorre porque o [Hydration Boundary](../reference/hydration.md#hydrationboundary) coloca dados necessários no cache para o rendering, mas se o garbage collector remover os dados antes do rendering ser concluído, problemas podem surgir. Se você precisa de um `gcTime` menor, recomendamos defini-lo como `2 * 1000` para permitir tempo suficiente para a aplicação referenciar os dados.

Para limpar o cache depois que ele não é mais necessário e reduzir o consumo de memória, você pode adicionar uma chamada a [`queryClient.clear()`](../../../reference/QueryClient.md#queryclientclear) depois que a requisição for tratada e o state desidratado tiver sido enviado ao cliente.

Alternativamente, você pode definir um `gcTime` menor.

### Ressalva para rewrites do Next.js

Existe uma pegadinha se você está usando o [recurso de rewrites do Next.js](https://nextjs.org/docs/app/api-reference/next-config-js/rewrites) junto com [Automatic Static Optimization](https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization) ou `getStaticProps`: isso causará uma segunda hydration pelo React Query. Isso acontece porque o [Next.js precisa garantir que os rewrites sejam parseados](https://nextjs.org/docs/app/api-reference/next-config-js/rewrites#rewrite-parameters) no cliente e coletar quaisquer parâmetros após a hydration para que possam ser fornecidos em `router.query`.

O resultado é a falta de igualdade referencial para todos os dados de hydration, o que, por exemplo, dispara onde quer que seus dados sejam usados como props de components ou no array de dependências de `useEffect`s/`useMemo`s.
