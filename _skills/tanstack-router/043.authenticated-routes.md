---
id: authenticated-routes
title: Authenticated Routes
---

Autenticação é um requisito extremamente comum para aplicações web. Neste guia, vamos mostrar como usar o TanStack Router para construir routes protegidos e como redirecionar usuários para o login se eles tentarem acessá-los.

## A Opção `route.beforeLoad`

A opção `route.beforeLoad` permite que você especifique uma função que será chamada antes de um route ser carregado. Ela recebe todos os mesmos argumentos que a função `route.loader`. Este é um ótimo lugar para verificar se um usuário está autenticado e redirecioná-lo para uma página de login se não estiver.

A função `beforeLoad` executa em ordem relativa a estas outras funções de carregamento de route:

- Correspondência de Route (de Cima para Baixo)
  - `route.params.parse`
  - `route.validateSearch`
- Carregamento de Route (incluindo Preloading)
  - **`route.beforeLoad`**
  - `route.onError`
- Carregamento de Route (Paralelo)
  - `route.component.preload?`
  - `route.load`

**É importante saber que a função `beforeLoad` de um route é chamada _antes de qualquer função `beforeLoad` dos seus routes filhos_.** Ela é essencialmente uma função de middleware para o route e todos os seus filhos.

**Se você lançar um erro em `beforeLoad`, nenhum dos seus filhos tentará carregar**.

## Redirecionamento

Embora não seja obrigatório, alguns fluxos de autenticação requerem redirecionamento para uma página de login. Para fazer isso, você pode **lançar um `redirect()`** do `beforeLoad`:

```tsx
// src/routes/_authenticated.tsx
export const Route = createFileRoute("/_authenticated")({
  beforeLoad: async ({ location }) => {
    if (!isAuthenticated()) {
      throw redirect({
        to: "/login",
        search: {
          // Use the current location to power a redirect after login
          // (Do not use `router.state.resolvedLocation` as it can
          // potentially lag behind the actual current location)
          redirect: location.href,
        },
      });
    }
  },
});
```

> [!TIP]
> A função `redirect()` aceita todas as mesmas opções que a função `navigate`, então você pode passar opções como `replace: true` se quiser substituir a entrada atual do histórico em vez de adicionar uma nova.

### Tratando Falhas na Verificação de Autenticação

Se sua verificação de autenticação pode lançar erros (falhas de rede, validação de token, etc.), envolva-a em try/catch:

```tsx
import { createFileRoute, redirect, isRedirect } from "@tanstack/react-router";

// src/routes/_authenticated.tsx
export const Route = createFileRoute("/_authenticated")({
  beforeLoad: async ({ location }) => {
    try {
      const user = await verifySession(); // might throw on network error
      if (!user) {
        throw redirect({
          to: "/login",
          search: { redirect: location.href },
        });
      }
      return { user };
    } catch (error) {
      // Re-throw redirects (they're intentional, not errors)
      if (isRedirect(error)) throw error;

      // Auth check failed (network error, etc.) - redirect to login
      throw redirect({
        to: "/login",
        search: { redirect: location.href },
      });
    }
  },
});
```

O helper [`isRedirect()`](../api/router/isRedirectFunction.md) distingue entre erros reais e redirecionamentos intencionais.

Uma vez que você autenticou um usuário, também é prática comum redirecioná-lo de volta para a página que ele estava tentando acessar. Para fazer isso, você pode utilizar o parâmetro de busca `redirect` que adicionamos no nosso redirecionamento original. Como estaremos substituindo toda a URL pelo que era antes, `router.history.push` é mais adequado para isso do que `router.navigate`:

```tsx
router.history.push(search.redirect);
```

## Autenticação Sem Redirecionamento

Algumas aplicações escolhem não redirecionar usuários para uma página de login, e em vez disso mantêm o usuário na mesma página e mostram um formulário de login que substitui o conteúdo principal ou o esconde via modal. Isso também é possível com o TanStack Router simplesmente interrompendo o rendering do `<Outlet />` que normalmente renderizaria os routes filhos:

```tsx
// src/routes/_authenticated.tsx
export const Route = createFileRoute("/_authenticated")({
  component: () => {
    if (!isAuthenticated()) {
      return <Login />;
    }

    return <Outlet />;
  },
});
```

Isso mantém o usuário na mesma página, mas ainda permite que você renderize um formulário de login. Uma vez que o usuário está autenticado, você pode simplesmente renderizar o `<Outlet />` e os routes filhos serão renderizados.

## Autenticação usando context/hooks do React

Se seu fluxo de autenticação depende de interações com context e/ou hooks do React, você precisará passar seu state de autenticação para o TanStack Router usando a opção `router.context`.

> [!IMPORTANT]
> Hooks do React não foram feitos para serem consumidos fora de components React. Se você precisa usar um hook fora de um component React, você precisa extrair o state retornado do hook em um component que envolve seu `<RouterProvider />` e então passar o valor retornado para o TanStack Router.

Vamos cobrir as opções de `router.context` em detalhes na seção [Router Context](./router-context.md).

Aqui está um exemplo que usa context e hooks do React para proteger routes autenticados no TanStack Router. Veja o setup completo funcionando no [exemplo de Authenticated Routes](https://github.com/TanStack/router/tree/main/examples/react/authenticated-routes).

- `src/routes/__root.tsx`

```tsx
import { createRootRouteWithContext } from "@tanstack/react-router";

interface MyRouterContext {
  // The ReturnType of your useAuth hook or the value of your AuthContext
  auth: AuthState;
}

export const Route = createRootRouteWithContext<MyRouterContext>()({
  component: () => <Outlet />,
});
```

- `src/router.tsx`

```tsx
import { createRouter } from "@tanstack/react-router";

import { routeTree } from "./routeTree.gen";

export const router = createRouter({
  routeTree,
  context: {
    // auth will initially be undefined
    // We'll be passing down the auth state from within a React component
    auth: undefined!,
  },
});
```

- `src/App.tsx`

```tsx
import { RouterProvider } from "@tanstack/react-router";

import { AuthProvider, useAuth } from "./auth";

import { router } from "./router";

function InnerApp() {
  const auth = useAuth();
  return <RouterProvider router={router} context={{ auth }} />;
}

function App() {
  return (
    <AuthProvider>
      <InnerApp />
    </AuthProvider>
  );
}
```

Então no route autenticado, você pode verificar o state de autenticação usando a função `beforeLoad`, e **lançar um `redirect()`** para o seu **route de Login** se o usuário não estiver logado.

- `src/routes/dashboard.route.tsx`

```tsx
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard")({
  beforeLoad: ({ context, location }) => {
    if (!context.auth.isAuthenticated) {
      throw redirect({
        to: "/login",
        search: {
          redirect: location.href,
        },
      });
    }
  },
});
```

Você pode _opcionalmente_ também usar a abordagem de [Autenticação Sem Redirecionamento](#autenticação-sem-redirecionamento) para mostrar um formulário de login em vez de chamar um **redirect**.

Essa abordagem também pode ser usada em conjunto com Route Sem Caminho ou Layout Route para proteger todos os routes sob seu route pai.

## Guias Práticos Relacionados

Para guias de implementação detalhados e passo a passo, veja:

- [Como Configurar Autenticação Básica](../how-to/setup-authentication.md) - Setup completo com React Context e routes protegidos
- [Como Integrar Provedores de Autenticação](../how-to/setup-auth-providers.md) - Use Auth0, Clerk ou Supabase
- [Como Configurar Controle de Acesso Baseado em Papéis](../how-to/setup-rbac.md) - Implemente permissões e roteamento baseado em papéis

## Exemplos

Exemplos funcionais de autenticação estão disponíveis no repositório:

- [Exemplo de Autenticação Básica](https://github.com/TanStack/router/tree/main/examples/react/authenticated-routes) - Autenticação simples com context
- [Autenticação Firebase](https://github.com/TanStack/router/tree/main/examples/react/authenticated-routes-firebase) - Integração com Firebase Auth
- [Exemplos de Auth com TanStack Start](https://github.com/TanStack/router/tree/main/examples/react) - Várias implementações de autenticação com TanStack Start
