---
id: ssr
title: SSR
---

> [!WARNING]
> Embora todo esforço tenha sido feito para separar essas APIs de mudanças no Tanstack Start, existem implementações compartilhadas internamente. Portanto, estas podem estar sujeitas a alterações e devem ser consideradas experimentais até que o Start atinja o status estável.

Server Side Rendering (SSR) é o processo de renderizar um component no servidor e enviar o markup HTML para o client. O client então hidrata o markup em um component totalmente interativo.

Geralmente existem dois sabores diferentes de SSR a serem considerados:

- SSR sem streaming
  - A página inteira é renderizada no servidor e enviada ao client em uma única requisição HTML, incluindo os dados serializados que a aplicação precisa para hidratar no client.
- SSR com streaming
  - A primeira pintura crítica da página é renderizada no servidor e enviada ao client em uma única requisição HTML, incluindo os dados serializados que a aplicação precisa para hidratar no client
  - O restante da página é então transmitido via streaming para o client conforme é renderizado no servidor.

Este guia explicará como implementar ambos os sabores de SSR com o TanStack Router!

## SSR sem Streaming

O server-side rendering sem streaming é o processo clássico de renderizar o markup de toda a página da sua aplicação no servidor e enviar o HTML completo (e dados) para o client. O client então hidrata o markup em uma aplicação totalmente interativa novamente.

Para implementar SSR sem streaming com o TanStack Router, você precisará dos seguintes utilitários:

- `RouterClient` de `@tanstack/react-router`
  - ex: `<RouterClient router={router} />`
  - Renderizar esse component no seu client entry irá renderizar sua aplicação e também implementar automaticamente a opção `Wrap` do component no `Router`
- E, ou:
  - `defaultRenderHandler` de `@tanstack/react-router`
    - Isso irá renderizar sua aplicação no seu server entry e também tratar automaticamente a hydration/dehydration em nível de aplicação e também implementar automaticamente o component RouterServer.
      ou:
  - `renderRouterToString` de `@tanstack/react-router`
    - Isso difere do defaultRenderHandler pois permite que você especifique manualmente a opção `Wrap` do component no `Router` junto com quaisquer outros providers com os quais você precise envolvê-lo.
  - `RouterServer` de `@tanstack/react-router`
    - Isso implementa a opção `Wrap` do component no `Router`

### History Automático no Servidor

No client, o Router usa por padrão uma instância de `createBrowserHistory`, que é o tipo preferido de history para usar no client. No servidor, no entanto, você vai querer usar uma instância de `createMemoryHistory` em vez disso. Isso porque `createBrowserHistory` usa o objeto `window`, que não existe no servidor. Isso é tratado automaticamente para você no component RouterServer.

### Dehydration/Hydration Automática do Loader

Os dados resolvidos do loader buscados pelas routes são automaticamente desidratados e reidratados pelo TanStack Router, desde que você complete os passos padrão de SSR descritos neste guia.

⚠️ Se você estiver usando streaming de dados adiados, também precisará garantir que implementou o padrão de [SSR com Streaming e Transformação de Stream](#streaming-ssr) próximo ao final deste guia.

Para mais informações sobre como utilizar o data loading, consulte o guia de [Data Loading](./data-loading.md).

### Criação do Router

Como seu router existirá tanto no servidor quanto no client, é importante criar seu router de uma forma que seja consistente entre ambos os ambientes. A maneira mais fácil de fazer isso é expor uma função `createRouter` em um arquivo compartilhado que possa ser importado e chamado tanto pelo seu server entry quanto pelo client entry.

```tsx
// src/router.tsx
import { createRouter as createTanstackRouter } from "@tanstack/react-router";
import { routeTree } from "./routeTree.gen";

export function createRouter() {
  return createTanstackRouter({ routeTree });
}

declare module "@tanstack/react-router" {
  interface Register {
    router: ReturnType<typeof createRouter>;
  }
}
```

### Renderizando a Aplicação no Servidor

Agora que você tem uma instância do router que carregou todos os dados críticos para a URL atual, pode renderizar sua aplicação no servidor:

usando `defaultRenderHandler`

```tsx
// src/entry-server.tsx
import {
  createRequestHandler,
  defaultRenderToString,
} from "@tanstack/react-router/ssr/server";
import { createRouter } from "./router";

export async function render({ request }: { request: Request }) {
  const handler = createRequestHandler({ request, createRouter });

  return await handler(defaultRenderHandler);
}
```

usando `renderRouterToString`

```tsx
// src/entry-server.tsx
import {
  createRequestHandler,
  renderRouterToString,
  RouterServer,
} from "@tanstack/react-router/ssr/server";
import { createRouter } from "./router";

export function render({ request }: { request: Request }) {
  const handler = createRequestHandler({ request, createRouter });

  return handler(({ request, responseHeaders, router }) =>
    renderRouterToString({
      request,
      responseHeaders,
      router,
      children: <RouterServer router={router} />,
    }),
  );
}
```

NOTA: O método createRequestHandler requer um objeto Request padrão da web API, enquanto o método handler retornará uma promise de Response padrão da web API.

Caso você esteja usando um framework de servidor como o Express que usa seus próprios objetos Request e Response, será necessário converter de um para o outro. Por favor, consulte os exemplos para ver como essa implementação pode ser feita.

## Renderizando a Aplicação no Client

No client, as coisas são muito mais simples.

- Crie sua instância do router
- Renderize sua aplicação usando o component `<RouterClient />`

[//]: # "ClientEntryFileExample"

```tsx
// src/entry-client.tsx
import { hydrateRoot } from "react-dom/client";
import { RouterClient } from "@tanstack/react-router/ssr/client";
import { createRouter } from "./router";

const router = createRouter();

hydrateRoot(document, <RouterClient router={router} />);
```

[//]: # "ClientEntryFileExample"

Com essa configuração, sua aplicação será renderizada no servidor e depois hidratada no client!

## SSR com Streaming

SSR com streaming é o sabor mais moderno de SSR e é o processo de enviar continuamente e incrementalmente markup HTML para o client conforme é renderizado no servidor. Isso é ligeiramente diferente do SSR tradicional em conceito porque, além de poder desidratar e reidratar uma primeira pintura crítica, markup e dados com menor prioridade ou tempos de resposta mais lentos podem ser transmitidos via streaming para o client após o render inicial, mas na mesma requisição.

Esse padrão pode ser útil para páginas que têm requisitos de data fetching lentos ou com alta latência. Por exemplo, se você tem uma página que precisa buscar dados de uma API de terceiros, pode transmitir via streaming o markup e dados iniciais críticos para o client e depois transmitir os dados de terceiros menos críticos para o client conforme são resolvidos.

> [!NOTE]
> Esse padrão de streaming é totalmente automático desde que você esteja usando `defaultStreamHandler` ou `renderRouterToStream`.

usando `defaultStreamHandler`

```tsx
// src/entry-server.tsx
import {
  createRequestHandler,
  defaultStreamHandler,
} from "@tanstack/react-router/ssr/server";
import { createRouter } from "./router";

export async function render({ request }: { request: Request }) {
  const handler = createRequestHandler({ request, createRouter });

  return await handler(defaultStreamHandler);
}
```

usando `renderRouterToStream`

```tsx
// src/entry-server.tsx
import {
  createRequestHandler,
  renderRouterToStream,
  RouterServer,
} from "@tanstack/react-router/ssr/server";
import { createRouter } from "./router";

export function render({ request }: { request: Request }) {
  const handler = createRequestHandler({ request, createRouter });

  return handler(({ request, responseHeaders, router }) =>
    renderRouterToStream({
      request,
      responseHeaders,
      router,
      children: <RouterServer router={router} />,
    }),
  );
}
```

## Dehydration/Hydration com Streaming

Dehydration/hydration com streaming é um padrão avançado que vai além do markup e permite que você desidrate e transmita via streaming quaisquer dados de suporte do servidor para o client e os reidrate na chegada. Isso é útil para aplicações que podem precisar usar/gerenciar adicionalmente os dados subjacentes que foram usados para renderizar o markup inicial no servidor.

## Serialização de Dados

Ao usar SSR, os dados passados entre o servidor e o client devem ser serializados antes de serem enviados através de limites de rede. O TanStack Router lida com essa serialização usando um serializador muito leve que suporta tipos de dados comuns além de JSON.stringify/JSON.parse.

Por padrão, os seguintes tipos são suportados:

- `undefined`
- `Date`
- `Error`
- `FormData`

Se você acha que existem outros tipos que deveriam ser suportados por padrão, por favor abra uma issue no repositório do TanStack Router.

Se você está usando tipos de dados mais complexos como `Map`, `Set`, `BigInt`, etc, pode precisar usar um serializador customizado para garantir que suas definições de tipo sejam precisas e seus dados sejam corretamente serializados e desserializados. Estamos atualmente trabalhando tanto em um serializador mais robusto quanto em uma forma de customizar o serializador para sua aplicação. Abra uma issue se você estiver interessado em ajudar!
